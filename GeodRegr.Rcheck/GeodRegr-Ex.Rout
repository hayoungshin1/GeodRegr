
R version 4.0.0 (2020-04-24) -- "Arbor Day"
Copyright (C) 2020 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "GeodRegr"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> options(pager = "console")
> library('GeodRegr')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("are")
> ### * are
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: are
> ### Title: Approximate ARE of an M-type estimator to the least-squares
> ###   estimator
> ### Aliases: are
> 
> ### ** Examples
> 
> are('l1', 10)
[1] 0.9513078
> 
> 
> 
> 
> cleanEx()
> nameEx("are_nr")
> ### * are_nr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: are_nr
> ### Title: Newton-Raphson method for the 'are' function
> ### Aliases: are_nr
> 
> ### ** Examples
> 
> dimension <- 4
> x <- 1:10000 / 1000
> # use a graph of the are function to pick a good starting point
> plot(x, are('huber', dimension, x) - 0.95)
> are_nr('huber', dimension, 2)
[1] 1.731073
> 
> 
> 
> 
> cleanEx()
> nameEx("calvaria")
> ### * calvaria
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: calvaria
> ### Title: Data on calvaria growth in rat skulls
> ### Aliases: calvaria
> ### Keywords: datasets
> 
> ### ** Examples
> 
> # we will test the robustness of each estimator by comparing their
> # performance on the original (corrupted) data set to that of the L_2
> # estimator on the uncorrupted data set (with the 4 problematic data points
> # removed).
> 
> data(calvaria)
> 
> manifold <- 'kendall'
> 
> contam_x_data <- calvaria$x
> contam_mean_x <- mean(contam_x_data)
> contam_x_data <- contam_x_data - contam_mean_x # center x data
> uncontam_x_data <- calvaria$x[ -c(23, 101, 104, 160)]
> uncontam_mean_x <- mean(uncontam_x_data)
> uncontam_x_data <- uncontam_x_data - uncontam_mean_x # center x data
> 
> contam_y_data <- calvaria$y
> uncontam_y_data <- calvaria$y[, -c(23, 101, 104, 160)] # remove corrupted
>     # columns
> 
> landmarks <- dim(contam_y_data)[1]
> dimension <- 2 * landmarks - 4
> 
> # we ignore Huber's estimator as the L_1 estimator already has an
> # (approximate) efficiency above 95% in 12 dimensions; see documentation for
> # the are and are_nr functions
> 
> tol <- 1e-5
> uncontam_l2 <- geo_reg(manifold, uncontam_x_data, uncontam_y_data,
+     'l2', p_tol = tol, V_tol = tol)
> contam_l2 <- geo_reg(manifold, contam_x_data, contam_y_data,
+     'l2', p_tol = tol, V_tol = tol)
> contam_l1 <- geo_reg(manifold, contam_x_data, contam_y_data,
+     'l1', p_tol = tol, V_tol = tol)
> contam_tukey <- geo_reg(manifold, contam_x_data, contam_y_data,
+     'tukey', are_nr('tukey', dimension, 10, 0.99), p_tol = tol, V_tol = tol)
> 
> geodesics <- vector('list')
> geodesics[[1]] <- uncontam_l2
> geodesics[[2]] <- contam_l2
> geodesics[[3]] <- contam_l1
> geodesics[[4]] <- contam_tukey
> 
> loss(manifold, geodesics[[1]]$p, geodesics[[1]]$V, uncontam_x_data,
+     uncontam_y_data, 'l2')
[1] 0.1579578
> loss(manifold, geodesics[[2]]$p, geodesics[[2]]$V, contam_x_data,
+     contam_y_data, 'l2')
[1] 2.772349
> loss(manifold, geodesics[[3]]$p, geodesics[[3]]$V, contam_x_data,
+     contam_y_data, 'l1')
[1] 2.375891
> loss(manifold, geodesics[[4]]$p, geodesics[[4]]$V, contam_x_data,
+     contam_y_data, 'tukey', are_nr('tukey', dimension, 10, 0.99))
[1] 2.689958
> 
> # visualization of each geodesic
> 
> oldpar <- par(mfrow = c(1, 4))
> 
> days <- c(7, 14, 21, 30, 40, 60, 90, 150)
> pal <- colorRampPalette(c("blue", "red"))(length(days))
> 
> # each predicted geodesic will be represented as a sequence of the predicted
> # shapes at each of the above ages, the blue contour will show the predicted
> # shape on day 7 and the red contour the predicted shape on day 150
> 
> contour <- vector('list')
> 
> for (i in 1:length(days)) {
+   contour[[i]] <- exp_map(manifold, geodesics[[1]]$p, (days[i] -
+       uncontam_mean_x) * geodesics[[1]]$V)
+   contour[[i]] <- c(contour[[i]], contour[[i]][1])
+ }
> plot(Re(contour[[length(days)]]), Im(contour[[length(days)]]), type = 'n',
+     xaxt = 'n', yaxt = 'n', ann = FALSE, asp = 1)
>  for (i in 1:length(days)) {
+    lines(Re(contour[[i]]), Im(contour[[i]]), col = pal[i])
+ }
> for (j in 2:4) {
+   for (i in 1:length(days)) {
+     contour[[i]] <- exp_map(manifold, geodesics[[j]]$p, (days[i] -
+         contam_mean_x) * geodesics[[j]]$V)
+     contour[[i]] <- c(contour[[i]], contour[[i]][1])
+   }
+   plot(Re(contour[[length(days)]]), Im(contour[[length(days)]]), type = 'n',
+       xaxt = 'n', yaxt = 'n', ann = FALSE, asp = 1)
+   for (i in 1:length(days)) {
+     lines(Re(contour[[i]]), Im(contour[[i]]), col = pal[i])
+   }
+ }
> # even with a mere 4 corrupted landmarks out of a total of 8 * 168 = 1344, we
> # can clearly see that contam_l2, the second image, looks slightly
> # different from all the others, especially near the top of the image.
> 
> par(oldpar)
> 
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("exp_map")
> ### * exp_map
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: exp_map
> ### Title: Exponential map
> ### Aliases: exp_map
> 
> ### ** Examples
> 
> exp_map('sphere', c(1, 0, 0, 0, 0), c(0, 0, pi / 4, 0, 0))
[1] 0.7071068 0.0000000 0.7071068 0.0000000 0.0000000
> 
> 
> 
> 
> cleanEx()
> nameEx("geo_dist")
> ### * geo_dist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geo_dist
> ### Title: Geodesic distance between two points on a manifold
> ### Aliases: geo_dist
> 
> ### ** Examples
> 
> p1 <- matrix(rnorm(10), ncol = 2)
> p1 <- p1[, 1] + (1i) * p1[, 2]
> p1 <- (p1 - mean(p1)) / norm(p1 - mean(p1), type = '2')
> p2 <- matrix(rnorm(10), ncol = 2)
> p2 <- p2[, 1] + (1i) * p2[, 2]
> p2 <- (p2 - mean(p2)) / norm(p2 - mean(p2), type = '2')
> geo_dist('kendall', p1, p2)
[1] 0.8976401
> 
> 
> 
> 
> cleanEx()
> nameEx("geo_reg")
> ### * geo_reg
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geo_reg
> ### Title: Gradient descent for (robust) geodesic regression
> ### Aliases: geo_reg
> 
> ### ** Examples
> 
> # an example of multiple regression with two independent variables, with 64
> # data points
> 
> x <- matrix(runif(2 * 64), ncol = 2)
> x <- t(t(x) - colMeans(x))
> y <- matrix(0L, nrow = 4, ncol = 64)
> for (i in 1:64) {
+   y[, i] <- exp_map('sphere', c(1, 0, 0, 0), c(0, runif(1), runif(1),
+       runif(1)))
+ }
> geo_reg('sphere', x, y, 'tukey', c = are_nr('tukey', 2, 6))
$p
          [,1]
[1,] 0.6554008
[2,] 0.4385552
[3,] 0.4382677
[4,] 0.4313241

$V
           [,1]        [,2]
[1,] -0.1727844  0.03568851
[2,]  0.2554928 -0.12708726
[3,]  0.2076037  0.02218222
[4,] -0.2081744  0.05244952

$iteration
[1] 26

> 
> 
> 
> 
> cleanEx()
> nameEx("intrinsic_location")
> ### * intrinsic_location
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: intrinsic_location
> ### Title: Gradient descent for location based on M-type estimators
> ### Aliases: intrinsic_location
> 
> ### ** Examples
> 
> y <- matrix(runif(100, 1000, 2000), nrow = 10)
> intrinsic_location('euclidean', y, 'l2')
          [,1]
 [1,] 1511.307
 [2,] 1477.315
 [3,] 1547.415
 [4,] 1426.971
 [5,] 1532.974
 [6,] 1548.971
 [7,] 1531.881
 [8,] 1482.698
 [9,] 1591.480
[10,] 1527.459
> 
> 
> 
> 
> cleanEx()
> nameEx("log_map")
> ### * log_map
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: log_map
> ### Title: Logarithm map
> ### Aliases: log_map
> 
> ### ** Examples
> 
> log_map('sphere', c(0, 1, 0, 0), c(0, 0, 1, 0))
[1] 0.000000 0.000000 1.570796 0.000000
> 
> 
> 
> 
> cleanEx()
> nameEx("loss")
> ### * loss
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: loss
> ### Title: Loss
> ### Aliases: loss
> 
> ### ** Examples
> 
> y <- matrix(0L, nrow = 3, ncol = 64)
> for (i in 1:64) {
+   y[, i] <- exp_map('sphere', c(1, 0, 0), c(0, runif(1), runif(1)))
+ }
> intrinsic_mean <- intrinsic_location('sphere', y, 'l2')
> loss('sphere', intrinsic_mean, numeric(3), numeric(64), y, 'l2')
[1] 4.183404
> 
> 
> 
> 
> cleanEx()
> nameEx("onmanifold")
> ### * onmanifold
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: onmanifold
> ### Title: Manifold check and projection
> ### Aliases: onmanifold
> 
> ### ** Examples
> 
> y1 <- matrix(rnorm(10), ncol = 2)
> y1 <- y1[, 1] + (1i) * y1[, 2]
> y2 <- matrix(rnorm(10), ncol = 2)
> y2 <- y2[, 1] + (1i) * y2[, 2]
> y3 <- matrix(rnorm(10), ncol = 2)
> y3 <- y3[, 1] + (1i) * y3[, 2]
> y3 <- (y3 - mean(y3)) / norm(y3 - mean(y3), type = '2') # project onto preshape space
> y <- matrix(c(y1, y2, y3), ncol = 3)
> onmanifold('kendall', y)
$on
[1] FALSE FALSE  TRUE

$data
                      [,1]                  [,2]                  [,3]
[1,] -0.3227189-0.4080744i  0.4695294-0.1607414i  0.3007949+0.1050042i
[2,]  0.0232192+0.1504409i  0.1120633-0.1515833i  0.2516618+0.0692186i
[3,] -0.4120435+0.2575816i -0.2100830+0.1542954i -0.0023933-0.4029196i
[4,]  0.6260350+0.1881702i -0.7177828+0.1152284i -0.7434472-0.0465235i
[5,]  0.0855082-0.1881183i  0.3462731+0.0428009i  0.1933838+0.2752202i

> 
> 
> 
> 
> cleanEx()
> nameEx("par_trans")
> ### * par_trans
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: par_trans
> ### Title: Parallel transport
> ### Aliases: par_trans
> 
> ### ** Examples
> 
> p1 <- matrix(rnorm(10), ncol = 2)
> p1 <- p1[, 1] + (1i) * p1[, 2]
> p1 <- (p1 - mean(p1)) / norm(p1 - mean(p1), type = '2') # project onto pre-shape space
> p2 <- matrix(rnorm(10), ncol = 2)
> p2 <- p2[, 1] + (1i) * p2[, 2]
> p2 <- (p2 - mean(p2)) / norm(p2 - mean(p2), type = '2') # project onto pre-shape space
> p3 <- matrix(rnorm(10), ncol = 2)
> p3 <- p3[, 1] + (1i) * p3[, 2]
> p3 <- (p3 - mean(p3)) / norm(p3 - mean(p3), type = '2') # project onto pre-shape space
> v <- log_map('kendall', p1, p3)
> par_trans('kendall', p1, p2, v)
[1] -0.31953093-0.07360689i  0.37665528+0.06918359i -0.21787394+0.11028773i
[4]  0.00351587-0.05114427i  0.15723371-0.05472016i
> 
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  1.55 0.07 1.64 NA NA 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
