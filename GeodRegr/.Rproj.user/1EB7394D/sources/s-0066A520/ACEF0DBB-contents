## Kendall's shape space

```{r}

rm(list=ls())

## finding c for Huber,Tukey, and L_1 efficiency

Q <- function(s,x) {
  return (Rgamma(s,x,lower=F))
}

Qinv <- function(s,x) {
  return (Rgamma.inv(s,x,lower=F))
}

P <- function(s,x) {
  return (Rgamma(s,x,lower=T))
}

Pinv <- function(s,x) {
  return (Rgamma.inv(s,x,lower=T))
}

uppergamma <- function(s,x) {
  return (Igamma(s,x,lower=F))
}

lowergamma <- function(s,x) {
  return (Igamma(s,x,lower=T))
}

efficiency <- function (c,k,m_estimator) {
  if (m_estimator == 'huber') {
    numfactor <- (k/2)*lowergamma(k/2,0.5*c^2)+c*(k-1)*(2^-1.5)*uppergamma((k-1)/2,0.5*c^2)
    denfactor <- lowergamma((k+2)/2,0.5*c^2)+(0.5*c^2)*uppergamma(k/2,0.5*c^2)
  }
  if (m_estimator == 'tukey') {
    numfactor <- (2*(k+4)/(c^4))*lowergamma((k+4)/2,0.5*c^2)-(2*(k+2)/(c^2))*lowergamma((k+2)/2,0.5*c^2)+(k/2)*lowergamma(k/2,0.5*c^2)
    denfactor <- lowergamma((k+2)/2,0.5*c^2)-(8/(c^2))*lowergamma((k+4)/2,0.5*c^2)+(24/(c^4))*lowergamma((k+6)/2,0.5*c^2)-(32/(c^6))*lowergamma((k+8)/2,0.5*c^2)+(16/(c^8))*lowergamma((k+10)/2,0.5*c^2)
  }
  result <- (numfactor^2)/(gamma((k+2)/2)*denfactor)
  return (result-0.95)
}

l1_efficiency <- function(k) {
  return (((gamma((k+1)/2))^2)/((gamma(k/2)*gamma((k+2)/2))))
}

deriv <- function(c,k,m_estimator) {
  if (m_estimator == 'huber') {
    factor1 <- (k/2)*lowergamma(k/2,0.5*c^2)+c*(k-1)*(2^-1.5)*uppergamma((k-1)/2,0.5*c^2)
    factor2 <- lowergamma((k+2)/2,0.5*c^2)+(0.5*c^2)*uppergamma(k/2,0.5*c^2)
    factor3 <- (c^(k-1))*(2^(-k/2))*exp(-0.5*c^2)+(k-1)*(2^-1.5)*uppergamma((k-1)/2,0.5*c^2)
    factor4 <- c*uppergamma(k/2,0.5*c^2)
  }
  if (m_estimator == 'tukey') {
    factor1 <- (2*(k+4)/(c^4))*lowergamma((k+4)/2,0.5*c^2)-(2*(k+2)/(c^2))*lowergamma((k+2)/2,0.5*c^2)+(k/2)*lowergamma(k/2,0.5*c^2)
    factor2 <- lowergamma((k+2)/2,0.5*c^2)-(8/(c^2))*lowergamma((k+4)/2,0.5*c^2)+(24/(c^4))*lowergamma((k+6)/2,0.5*c^2)-(32/(c^6))*lowergamma((k+8)/2,0.5*c^2)+(16/(c^8))*lowergamma((k+10)/2,0.5*c^2)
    factor3 <- -(8*(k+4)/(c^5))*lowergamma((k+4)/2,0.5*c^2)+(4*(k+2)/(c^3))*lowergamma((k+2)/2,0.5*c^2)-c^(k-1)*2^(-((k-2)/2))*exp(-0.5*c^2)
    factor4 <- (16/(c^3))*lowergamma((k+4)/2,0.5*c^2)-(96/(c^5))*lowergamma((k+6)/2,0.5*c^2)+(192/(c^7))*lowergamma((k+8)/2,0.5*c^2)-(128/(c^9))*lowergamma((k+10)/2,0.5*c^2)
  }
  numerator <- 2*factor1*factor3*factor2-(factor1^2)*factor4
  denominator <- (gamma((k+2)/2))*factor2^2
  result <- numerator/denominator
  return (result)
}

nr <- function(c,k,m_estimator) { #Newton Raphson
  old_c <- c+5
  new_c <- c
  count <- 0
  while (abs(new_c-old_c)>0.000001) {
    old_c <- new_c
    new_c <- old_c-efficiency(old_c,k,m_estimator)/deriv(old_c,k,m_estimator)
    count <- count+1
    if (count > 1000) {
      return ('fail')
    }
  }
  if (m_estimator == 'tukey') {
    new_c <- abs(new_c)
  }
  return (new_c)
}

## Kendall's 2d shape space

norm <- function(v) {abs(sqrt(sum(v*Conj(v))))}

expo <- function(p,v) {
  p <- (p-mean(p))/norm(p-mean(p))
  theta <- norm(v)
  if (theta==0) {
    result <- p
  } else {
    e1 <- p
    e2 <- v/theta
    result <- cos(theta)*e1 + sin(theta)*e2
  }
  return (result)
}

loga <- function(p1,p2) {
  p1 <- (p1-mean(p1))/norm(p1-mean(p1))
  p2 <- (p2-mean(p2))/norm(p2-mean(p2))
  #q1 <- rbind(Re(q1),Im(q1))
  #q2 <- rbind(Re(q2),Im(q2))
  #decomp <- svd(q1%*%t(q2))
  #R <- (decomp$u)%*%t(decomp$v)
  #q2 <- R%*%q2
  #q1 <- q1[1,]+q1[2,]*(0+1i)
  #q2 <- q2[1,]+q2[2,]*(0+1i)
  if (norm(p1-p2) == 0) {
    result <- integer(length(p1))
  } else {
    #a <- Re(sum(q1*Conj(q2)))
    #a <- abs(sum(q1*Conj(q2)))
    a <- sum(p1*Conj(p2))
    theta <- acos(max(min(abs(a),1),-1))
    tang <- (a/abs(a))*p2 - abs(a)*p1
    if (norm(tang) == 0) {
      if ((p1[1] == p2[1])) {
        result <- integer(length(p1))
      }
    } else {
      result <- theta*(tang/norm(tang))
    }
  }
  return (result)
}

dist <- function(p1,p2) {
  return (norm(loga(p1,p2)))
}

gammaprime <- function(t,p,v) {
  return (loga(expo(p,t*v),expo(p,(t+1)*v)))
}

#su <- function(p1,p2,v) {
#  p1 <- (p1-mean(p1))/norm(p1-mean(p1))
#  p2 <- (p2-mean(p2))/norm(p2-mean(p2))
#  #rot <- atan((Re(sum(p1*Conj((0+1i)*p2))))/(Re(sum(p1*Conj(p2)))))
#  #p2 <- exp(rot*(0+1i))*p2
#  #p1 <- rbind(Re(p1),Im(p1))
#  #p2 <- rbind(Re(p2),Im(p2))
#  #decomp <- svd(p1%*%t(p2))
#  #R <- (decomp$u)%*%t(decomp$v)
#  #p2 <- R%*%p2
#  #p1 <- p1[1,]+p1[2,]*(0+1i)
#  #p2 <- p2[1,]+p2[2,]*(0+1i)
#  a <- sum(p1*Conj(p2))
#  if (abs(a)>=1) {
#    return (v)
#  } else {
#    a <- sum(p1*Conj(p2))
#    p2 <- (a/abs(a))*p2
#    a <- max(min(abs(a),1),-1)
#    b <- (1-a*a)^0.5
#    p2tilda <- (p2-a*p1)/b
#    U <- matrix(c(a,b,-b,a),nrow=2)
#    vc <- c(sum(v*Conj(p1)),sum(v*Conj(p2tilda)))
#    return (v+as.vector(matrix(c(p1,p2tilda),ncol=2)%*%(-vc+U%*%vc)))
#  }
#}

#pt <- function(p1,p2,v) {
#  z <- expo(p1,v)
#  tz <- sum(p1*Conj(z))
#  atz <- abs(tz)
#  zethetaSTARmu <- tz/atz
#  zSTARmu <- zethetaSTARmu*z ### optimal z wrt p1
#  tp2 <- sum(p1*Conj(p2))
#  atp2 <- abs(tp2)
#  p2ethetaSTARmu <- tp2/atp2
#  p2STARmu <- p2ethetaSTARmu*p2 ### optimal p2 wrt p1
#  ApRotResid <- su(p1,p2,v) ## rotated resid at p2STARmu
#  return ((Conj(tp2)/atp2)*ApRotResid)
#}

#pt <- function(p1,p2,v) {
#  z <- expo(p1,v)
#  tz <- sum(p1*Conj(z))
#  atz <- abs(tz)
#  zethetaSTARmu <- tz/atz
#  zSTARmu <- zethetaSTARmu*z ### optimal z wrt p1
#  tp2 <- sum(p1*Conj(p2))
#  atp2 <- abs(tp2)
#  p2ethetaSTARmu <- tp2/atp2
#  p2STARmu <- p2ethetaSTARmu*p2 ### optimal p2 wrt p1
#  ApRotResid <- su(p1,p2,v) ## rotated resid at p2STARmu
#  ArotResid <- (Conj(tp2)/atp2)*ApRotResid
#  if (atz >= 1) {
#    fac <- 1
#  } else {
#    fac <- acos(atz)/((1-atz^2)^0.5)
#  }
#  vterm <- su(p1,p2,zSTARmu)-atz*p2STARmu
#  pRotResid <- fac*vterm
#  #return (Conj(p2ethetaSTARmu)*loga(p2STARmu, su(p1,p2,z)))
#  return (Conj(p2ethetaSTARmu)*pRotResid)
#}

#pt <- function(p1,p2,v) {
#  yi <- expo(p1,v)
#  a <- sum(p2*Conj(p1))
#  p1 <- (a/abs(a))*p1 #p1 is now p1star
#  a <- abs(a)
#  if (a>=1) {
#    return (loga(p2,yi))
#  } else {
#    b <- (1-a^2)^0.5
#    p1tilda <- (p1-a*p2)/b
#    Uconjt <- diag(length(v)) - p2%*%t(Conj(p2))-p1tilda%*%t(Conj(p1tilda))+a*p2%*%t(Conj(p2))-b*p1tilda%*%t(Conj(p2))+b*p2%*%t(Conj(p1tilda))+a*p1tilda%*%t(Conj(p1tilda))
#    return (loga(p2,as.vector(Uconjt%*%yi)))
#    #return (as.vector(Uconjt%*%loga(p2,yi)))
#  }
#}

pt <- function(p1,p2,v) {
  p1 <- (p1-mean(p1))/norm(p1-mean(p1))
  p2 <- (p2-mean(p2))/norm(p2-mean(p2))
  yi <- expo(p1,v)
  a <- sum(p1*Conj(p2))
  p2 <- (a/abs(a))*p2 #p2 is now p2star
  if (abs(a)>=1) {
    result <- loga(p2,yi)
  } else {
    b <- (1-(abs(a))^2)^0.5
    p2tilda <- (p2-abs(a)*p1)/b
    result <- v-(sum(v*Conj(p1)))*p1-(sum(v*Conj(p2tilda)))*p2tilda+((abs(a))*(sum(v*Conj(p1)))-b*(sum(v*Conj(p2tilda))))*p1+(b*(sum(v*Conj(p1)))+(abs(a))*(sum(v*Conj(p2tilda))))*p2tilda
    result <- (Conj(a/abs(a)))*result
  }
  return (result)
}

#pt <- function(p1,v1,w1) { ####################### or here ################### remember, the result is only valid at this #specific representation (orientation) of expo(p1,v1), you may #need to rotate it, just like with loga
#  p1 <- p1/norm(p1)
#  if (norm(v1) != 0) {
#    e1 <- p1
#    e2 <- v1/norm(v1)
#    #a <- Re(sum(w1*Conj(e2)))
#    #a <- abs(sum(w1*Conj(e2)))
#    a <- sum(w1*Conj(e2))
#    #a <- sum(e2*Conj(w1))
#    #invar <- (a/abs(a))*w1 - abs(a)*e2
#    invar <- w1-a*e2
#    t <- norm(v1)
#    return (a*(cos(t)*e2-sin(t)*e1)+invar)
#  } else {
#    return (w1)
#  }
#}

rho <- function(x,m_estimator) {
  if (m_estimator[[1]] == 'l2') {
    result <- 0.5*x^2
  } else if (m_estimator[[1]] == 'l1') {
    result <- abs(x)
  } else if (m_estimator[[1]] == 'huber') {
    if (abs(x) < m_estimator[[2]]) {
      result <- 0.5*x^2
    } else {
      result <- m_estimator[[2]]*abs(x)-0.5*m_estimator[[2]]^2
    }
  } else if (m_estimator[[1]] == 'tukey') {
    if (abs(x) < m_estimator[[2]]) {
      result <- ((m_estimator[[2]]^2)/6)*(1-(1-(x/m_estimator[[2]])^2)^3)
    } else {
      result <- (m_estimator[[2]]^2)/6
    }
  }
  return (result)
}

rho_prime <- function(x,m_estimator) {
  if (m_estimator[[1]] == 'l2') {
    result <- x
  } else if (m_estimator[[1]] == 'l1') {
    result <- sign(x)
  } else if (m_estimator[[1]] == 'huber') {
    if (abs(x) < m_estimator[[2]]) {
      result <- x
    } else {
      result <- m_estimator[[2]]*sign(x)
    }
  } else if (m_estimator[[1]] == 'tukey') {
    if (abs(x) < m_estimator[[2]]) {
      result <- x*((1-(x/m_estimator[[2]])^2)^2)*sign(x)
    } else {
      result <- 0
    }
  }
  return (result)
}

eps <- function(p,v,x,y) {
  answer <- matrix(,nrow=length(p),ncol=dim(y)[2])
  shifts <- v%*%t(x)
  for (i in 1:dim(y)[2]) {
    answer[,i] <-loga(expo(p, shifts[,i]), y[,i])
  }
  return (answer)
}

loss_sum <- function(p,v,x,y,m_estimator) {
  sum <- 0
  res <- eps(p,v,x,y)
  for (i in 1:dim(y)[2]) {
    sum <- sum + rho(norm(res[,i]),m_estimator)
  }
  return (sum)
}

j_p <- function(p,v1,v2) {
  if (norm(v1) != 0) {
    j <- (0+1i)*v1
    #v2_0 <- pt(expo(p,v1),-gammaprime(1,p,v1),v2)
    v2_0 <- pt(expo(p,v1),p,v2)
    #v2_0 <- reorient(expo(expo(p,v1),-gammaprime(1,p,v1)),v2_0,p)
    #v2_0 <- pt(expo(p,v1),p,v2)
    #u_0 <- (abs(sum(v2_0*Conj(j/norm(j)))))*(j/norm(j))
    w_0 <- (Re(sum(v2_0*Conj(j/norm(j)))))*(j/norm(j))
    #u_0 <- sum(v2_0*Conj(j/norm(j)))*(j/norm(j))
    #u_0 <- sum(Conj(v2_0)*(j/norm(j)))*(j/norm(j))
    u_0 <- v2_0-w_0
    #u_0 <- pt(expo(p,v1),p,u)
    #u_tan <- (abs(sum(u_0*Conj(v1/norm(v1)))))*(v1/norm(v1))
    w_tan <- (Re(sum(w_0*Conj(v1/norm(v1)))))*(v1/norm(v1))
    #u_tan <- (sum(u_0*Conj(v1/norm(v1))))*(v1/norm(v1))
    #u_tan <- (sum(Conj(u_0)*(v1/norm(v1))))*(v1/norm(v1))
    w_orth <- w_0-w_tan
    #w_0 <- pt(expo(p,v1),-gammaprime(1,p,v1),w)
    #w_tan <- (abs(sum(w_0*Conj(v1/norm(v1)))))*(v1/norm(v1))
    u_tan <- (Re(sum(u_0*Conj(v1/norm(v1)))))*(v1/norm(v1))
    #w_tan <- (sum(w_0*Conj(v1/norm(v1))))*(v1/norm(v1))
    #w_tan <- (sum(Conj(w_0)*(v1/norm(v1))))*(v1/norm(v1))
    u_orth <- u_0-u_tan
    L <- norm(v1)
    result <- cos(L)*u_orth + cos(2*L)*w_orth + u_tan + w_tan
  } else {
    result <- v2
  }
  return (result)
}

j_v <- function(p,v1,v2) { 
  if (norm(v1) != 0) {
    j <- (0+1i)*v1
    #v2_0 <- pt(expo(p,v1),-gammaprime(1,p,v1),v2)
    v2_0 <- pt(expo(p,v1),p,v2)
    #v2_0 <- reorient(expo(expo(p,v1),-gammaprime(1,p,v1)),v2_0,p)
    #v2_0 <- pt(expo(p,v1),p,v2)
    #u_0 <- (abs(sum(v2_0*Conj(j/norm(j)))))*(j/norm(j))
    w_0 <- (Re(sum(v2_0*Conj(j/norm(j)))))*(j/norm(j))
    #u_0 <- sum(v2_0*Conj(j/norm(j)))*(j/norm(j))
    #u_0 <- sum(Conj(v2_0)*(j/norm(j)))*(j/norm(j))
    u_0 <- v2_0-w_0
    #u_0 <- pt(expo(p,v1),p,u)
    #u_tan <- (abs(sum(u_0*Conj(v1/norm(v1)))))*(v1/norm(v1))
    w_tan <- (Re(sum(w_0*Conj(v1/norm(v1)))))*(v1/norm(v1))
    #u_tan <- (sum(u_0*Conj(v1/norm(v1))))*(v1/norm(v1))
    #u_tan <- (sum(Conj(u_0)*(v1/norm(v1))))*(v1/norm(v1))
    w_orth <- w_0-w_tan
    #w_0 <- pt(expo(p,v1),-gammaprime(1,p,v1),w)
    #w_tan <- (abs(sum(w_0*Conj(v1/norm(v1)))))*(v1/norm(v1))
    u_tan <- (Re(sum(u_0*Conj(v1/norm(v1)))))*(v1/norm(v1))
    #w_tan <- (sum(w_0*Conj(v1/norm(v1))))*(v1/norm(v1))
    #w_tan <- (sum(Conj(w_0)*(v1/norm(v1))))*(v1/norm(v1))
    u_orth <- u_0-u_tan
    L <- norm(v1)
    result <- ((sin(L))/L)*u_orth + ((sin(2*L))/(2*L))*w_orth + u_tan + w_tan
  } else {
    result <- v2
  }
  return (result)
}

grad_p <- function(p,v,x,y,m_estimator) {
  sum <- integer(length(p))
  res <- eps(p,v,x,y)
  if (dim(x)[2]==1) {
    for (i in 1:dim(y)[2]) {
      if (norm(res[,i])!=0) {
        sum <- sum - rho_prime(norm(res[,i]),m_estimator)*j_p(p,x[i]*as.vector(v),(res[,i]/norm(res[,i])))
      }
    }    
  } else {
    shifts <- v%*%t(x)
    for (i in 1:dim(y)[2]) {
      if (norm(res[,i])!=0) {
        sum <- sum - rho_prime(norm(res[,i]),m_estimator)*pt(expo(p, shifts[,i]),p,(res[,i]/norm(res[,i])))
      }
    }
  }
  return (sum)
}

grad_v <- function(p,v,x,y,m_estimator) {
  sum <- matrix(0L,nrow=length(p),ncol=dim(x)[2])
  res <- eps(p,v,x,y)
  if (dim(x)[2]==1) {
    for (i in 1:dim(y)[2]) {
      if (norm(res[,i])!=0) {
        sum <- sum - x[i]*rho_prime(norm(res[,i]),m_estimator)*j_v(p,x[i]*as.vector(v),(res[,i]/norm(res[,i])))
      }
    }    
  } else {
    shifts <- v%*%t(x)
    for (h in 1:dim(x)[2]) {
      for (i in 1:dim(y)[2]) {
        if (norm(res[,i])!=0) {
          sum[,h] <- sum[,h] - x[i,h]*rho_prime(norm(res[,i]),m_estimator)*pt(expo(p, shifts[,i]),p,(res[,i]/norm(res[,i])))
        }
      }
    }
  }
  return (sum)
}

#reorient <- function(p1,v,p2) { ### p1 and p2 belong to same equivalence class, move tangent vector from p1 to p2
#  return (loga(p2,expo(p1,v)))
#}

alg <- function(p,v,x,y,m_estimator) {
  p <- (p-mean(p))/norm(p-mean(p))
  current_p <- p
  current_v <- v
  old_p <- integer(length(p))
  old_p[1] <- 0.5^0.5
  old_p[dim(y)[1]] <- -(0.5^0.5)
  old_v <- matrix(0L,nrow=length(p),ncol=dim(x)[2])
  ##copy_old_p <- old_p
  ##copy_old_v <- old_v
  count <- 0
  alt_count <- 0
  if ((m_estimator[[1]] == 'huber') | (m_estimator[[1]] == 'tukey')) { 
    xi <- (2*Pinv(dim/2,0.5))^0.5
    deviations <- vector(length=dim(y)[2])
    current_shifts <- current_v%*%t(x)
    for (i in 1:dim(y)[2]) {
      deviations[i] <- dist(expo(current_p,current_shifts[,i]),y[,i])
    }
    mad <- median(deviations)
    if (m_estimator[[1]] == 'huber') {
      c <- nr(2,(2*length(p)-4),m_estimator)
    } else if (m_estimator[[1]] == 'tukey') {
      #c <- nr(8,(2*length(p)-4),m_estimator)
      c <- nr(15,(2*length(p)-4),m_estimator)
    }
    sigma <- mad/xi
    cutoff <- c*sigma
    rho_function <- m_estimator
    m_estimator <- vector('list',length=2)
    m_estimator[[1]] <- rho_function
    m_estimator[[2]] <- cutoff
  }
  step_p <- grad_p(current_p,current_v,x,y,m_estimator)
  step_v <- grad_v(current_p,current_v,x,y,m_estimator)
  v_diffs <- vector(length=dim(x)[2])
  for (h in 1:dim(x)[2]) {
    v_diffs[h] <- norm((pt(old_p,current_p,old_v[,h])-current_v[,h]))
  }
  lambda <- min((1/norm(step_p)),0.1)
  while ((count==0) | ((count<20000) & (alt_count<100000) & ((dist(old_p,current_p)>0.0000001) | (any(v_diffs>0.0000001))))) { ##& ((dist(copy_old_p,current_p)!=0) | (norm(current_v-copy_old_v)!=0)))) {
    new_p <- expo(current_p, -lambda*step_p)
    new_v <- matrix(,nrow=length(p),ncol=dim(x)[2])
    for (h in 1:dim(x)[2]) {
      new_v[,h] <- pt(current_p,new_p,current_v[,h]-lambda*step_v[,h])
    }
    if (loss_sum(current_p,current_v,x,y,m_estimator) >= loss_sum(new_p,new_v,x,y,m_estimator)) {
      alt_count <- 0
      ##copy_old_p <- old_p
      ##copy_old_v <- old_v
      old_p <- current_p
      old_v <- current_v
      current_p <- new_p
      current_v <- new_v
      if ((m_estimator[[1]] == 'huber') | (m_estimator[[1]] == 'tukey')) {
        ##xi <- (2*Pinv(dim/2,0.5*P(dim/2,0.5*(pi/sigma)^2)))^0.5
        current_shifts <- current_v%*%t(x)
        for (i in 1:dim(y)[2]) {
          deviations[i] <- dist(expo(current_p,current_shifts[,i]),y[,i])
        }
        mad <- median(deviations)
        ##old_c <- c
        ##c <- trunc_nr(old_c,dim,pi/sigma,m_estimator[[1]])
        ##if (c == 'fail') {
        ##  c <- old_c
        ##}
        sigma <- mad/xi
        cutoff <- c*sigma
        m_estimator[[2]] <- cutoff
      }
      step_p <- grad_p(current_p,current_v,x,y,m_estimator)
      step_v <- grad_v(current_p,current_v,x,y,m_estimator)
      for (h in 1:dim(x)[2]) {
        v_diffs[h] <- norm((pt(old_p,current_p,old_v[,h])-current_v[,h]))
      }
      lambda <- min((1/norm(step_p)),2*lambda)
      count <- count+1
    } else {
      lambda <- lambda/2
      alt_count <- alt_count+1
    }
  }
  result <- vector("list", length=5)
  result[[1]] <- current_p
  result[[2]] <- current_v
  #result[[3]] <- count
  #result[[4]] <- alt_count
  #result[[5]] <- lambda
  #if ((m_estimator[[1]] == 'huber') | (m_estimator[[1]] == 'tukey')) {
  #  result[[6]] <- sigma
  #  result[[7]] <- cutoff
  #  result[[8]] <- xi
  #  result[[9]] <- c
  #}
  return (result)
}

## Karcher mean on Kendall's 2d shape space

k_mean_loss_sum <- function(p,y) {
  sum <- 0
  for (i in 1:dim(y)[2]) {
    sum <- sum + 0.5*((dist(p,y[,i]))^2)
  }
  return (sum)
}

k_mean_grad <- function(p,y) {
  sum <- integer(length(p))
  for (i in 1:dim(y)[2]) {
    sum <- sum - loga(p,y[,i])
  }
  return (sum)
}

k_mean <- function(y) {
  current_p <- y[,1]
  old_p <- y[,2]
  lambda <- 0.1
  step_p <- k_mean_grad(current_p,y)
  count <- 0
  while ((count==0) | (dist(old_p,current_p)>0.0000001)) {
    lambda <- min((1/norm(step_p)),lambda)
    new_p <- expo(current_p, -lambda*step_p)
    if (k_mean_loss_sum(current_p,y) >= k_mean_loss_sum(new_p,y)) {
      ##alt_count <- 0
      old_p <- current_p
      current_p <- new_p
      step_p <- k_mean_grad(current_p,y)
      lambda <- 2*lambda
      count <- count+1
    } else {
      lambda <- lambda/2
    }
  }
  result <- current_p
  return (result) 
}

#data

library(mvtnorm)
library(zipfR)
library(MASS)
library(R.matlab)
library(rmatio)
#library(abind)
#library(data.table)

#initializations

boundary_points <- 50
dim <- 2*boundary_points-4
embed <- boundary_points
n <- 1
estimator <- 'l2'

# data

#NCF_x_data <- readMat('../downloads/ADNI_RMRSS/data/NCinfoF.mat')$NCinfoF
#NCM_x_data <- readMat('../downloads/ADNI_RMRSS/data/NCinfoM.mat')$NCinfoM
ADF_x_data <- readMat('../downloads/ADNI_RMRSS/ADNI_RMRSS/data/ADinfoF.mat')$ADinfoF
#ADM_x_data <- readMat('../downloads/ADNI_RMRSS/data/ADinfoM.mat')$ADinfoM

#NCF_y_data <- readMat('../downloads/ADNI_RMRSS/data/NCLdataF.mat')$NCLdataF
#NCM_y_data <- readMat('../downloads/ADNI_RMRSS/data/NCLdataM.mat')$NCLdataM
ADF_y_data <- readMat('../downloads/ADNI_RMRSS/ADNI_RMRSS/data/ADLdataF.mat')$ADLdataF
#ADM_y_data <- readMat('../downloads/ADNI_RMRSS/data/ADLdataM.mat')$ADLdataM

ages <- ADF_x_data[,9] ###############################################

x_data <- t(t(ages))
x_data <- x_data-mean(x_data) ## centering
#x_data <- c(x_data,0)

y_data <- ADF_y_data
y_data <- aperm(y_data, c(2,1,3))

#y_data[,49:50,((length(ages)-19):length(ages))] <- 9999 ########### outliers

for (i in 1:length(ages)) { ## remove translation
  for (j in 1:2) {
    y_data[j,,i] <- y_data[j,,i]-mean(y_data[j,,i])
  }
}

#y_data <- y_data[,1:embed,] ## remove last point, since it is determined by the first 49 points

for (i in 1:length(ages)) { ## remove scaling
  y_data[,,i] <- y_data[,,i]/((sum(y_data[,,i]*y_data[,,i]))^0.5)
}

#y_data[2,,(length(ages)-19):length(ages)] <- -y_data[2,,(length(ages)-19):length(ages)] ### fake points

#fake_point <- vector(length=boundary_points)
#fake_point[1] <- exp((pi/boundary_points)*((-1+0i)^0.5))
#for (i in 2:boundary_points) {
#  fake_point[i] <- (fake_point[1])^i
#}
#fake_point <- ((1/boundary_points)^0.5)*fake_point
#fake_point <- rbind(Re(fake_point),Im(fake_point))
#y_data <- abind(y_data,fake_point)

#target <- y_data[,,1]
#for (i in 1:length(ages)) {
#  decomp <- svd(target%*%t(y_data[,,i]))
#  R <- (decomp$u)%*%t(decomp$v)
#  y_data[,,i] <- R%*%y_data[,,i]
#}

#count <- 0
#old_target <- -y_data[,,1] ## remove rotation, general procrustes analysis
#current_target <- y_data[,,1]
#while ((sum((current_target-old_target)*(current_target-old_target))^0.5)>0.00000001) {
#  for (i in 1:length(ages)) {
#    decomp <- svd(current_target%*%t(y_data[,,i]))
#    R <- (decomp$u)%*%t(decomp$v)
#    y_data[,,i] <- R%*%y_data[,,i]
#  }
#  old_target <- current_target
#  current_target <- rowSums(y_data,dims=2)
#  current_target <- current_target/((sum(current_target*current_target))^0.5)
#  count <- count+1
#}

y_data <- y_data[1,,]+y_data[2,,]*(0+1i)
##y_data <- rbind(Re(y_data),Im(y_data))
#fake_point <- vector(length=boundary_points)
#fake_point[1] <- exp((2*pi/boundary_points)*(0+1i))
#for (i in 2:boundary_points) {
#  fake_point[i] <- (fake_point[1])^i
#}
#fake_point <- ((1/boundary_points)^0.5)*fake_point
#y_data[,(length(ages)-19):length(ages)] <- fake_point

## solutions

##init_p <- expo(y_data[,7],0.5*loga(y_data[,7],y_data[,12]))
##init_p <- expo(y_data[,1],0.5*loga(y_data[,1],y_data[,2]))
init_p <- k_mean(y_data)
init_v <- t(t(integer(embed)))

ans <- alg(init_p,init_v,x_data,y_data,estimator)

total_var <- k_mean_loss_sum(k_mean(y_data),y_data)
unexp_var <- loss_sum(ans[[1]],ans[[2]],x_data,y_data,'l2')
r_sq <- 1-unexp_var/total_var

r_sq

#ans[[1]]
#t(ans[[2]])
#sum(ans[[1]]*Conj(ans[[2]]))
#norm(ans[[1]])
#sum(ans[[1]])
#sum(ans[[2]])
#ans[[3]]
#ans[[4]]
#ans[[5]]



dist(p0,p1)
dist(p0,p2)
dist(p0,p3)
dist(p0,p4)
dist(p0,p5)
dist(p1,p4)
dist(p2,p5)
norm(v0-pt(p1,p0,v1))
norm(v0-pt(p2,p0,v2))
norm(v0-pt(p3,p0,v3))
norm(v0-pt(p4,p0,v4))
norm(v0-pt(p5,p0,v5))
norm(v1-pt(p4,p1,v4))
norm(v2-pt(p5,p2,v5))
















## data 

boundary_points <- 64
dim <- 2*boundary_points-4
embed <- boundary_points
M <- 1024
l <- 1
estimator <- 'l2'

ages <- t(t(c(49,47,81,55,38,64,74,65,19,48,69,73,83,52,24,86,24,80,48,20,58,63,60,77,21,23,24,90,46,55,67,20)))

x_data <- ages
x_data <- x_data-mean(x_data) ## centering
#x_data <- c(x_data,0)

y_data <- array(,c(2,boundary_points,length(ages)))

for (i in 1:10) {
  points <- as.matrix(read.table(file=paste(c("C:/Users/hc.gong/Downloads/cc-shapes/cc.0",(i-1),".lpts"), collapse = "")))
  points[,1] <- -points[,1]
  colnames(points) <- NULL
  y_data[,,i] <- t(points)
}
for (i in 11:32) {
  points <- as.matrix(read.table(file=paste(c("C:/Users/hc.gong/Downloads/cc-shapes/cc.",(i-1),".lpts"), collapse = "")))
  points[,1] <- -points[,1]
  colnames(points) <- NULL
  y_data[,,i] <- t(points)
}

for (i in 1:length(ages)) { ## remove translation
  for (j in 1:2) {
    y_data[j,,i] <- y_data[j,,i]-mean(y_data[j,,i])
  }
}

#y_data <- y_data[,1:embed,] ## remove last point, since it is determined by the first 49 points

for (i in 1:length(ages)) { ## remove scaling
  y_data[,,i] <- y_data[,,i]/((sum(y_data[,,i]*y_data[,,i]))^0.5)
}

#y_data[2,,(length(ages)-9):length(ages)] <- -y_data[2,,(length(ages)-9):length(ages)] ### fake points

#target <- y_data[,,1]
#for (i in 1:length(ages)) {
#  decomp <- svd(target%*%t(y_data[,,i]))
#  R <- (decomp$u)%*%t(decomp$v)
#  y_data[,,i] <- R%*%y_data[,,i]
#}

#count <- 0
#old_target <- -y_data[,,1] ## remove rotation, general procrustes analysis
#current_target <- y_data[,,1]
#while ((sum((current_target-old_target)*(current_target-old_target))^0.5)>0.00000001) {
#  for (i in 1:length(ages)) {
#    decomp <- svd(current_target%*%t(y_data[,,i]))
#    R <- (decomp$u)%*%t(decomp$v)
#    y_data[,,i] <- R%*%y_data[,,i]
#  }
#  old_target <- current_target
#  current_target <- rowSums(y_data,dims=2)
#  current_target <- current_target/((sum(current_target*current_target))^0.5)
#  count <- count+1
#}

y_data <- y_data[1,,]+y_data[2,,]*(0+1i)

#fake_point <- vector(length=boundary_points)
#fake_point[1] <- exp((2*pi/boundary_points)*(0+1i))
#for (i in 2:boundary_points) {
#  fake_point[i] <- (fake_point[1])^i
#}
#fake_point <- ((1/boundary_points)^0.5)*fake_point
#y_data[,(length(ages)-9):length(ages)] <- fake_point

#y_data[,(length(ages)-9):length(ages)] <- Conj(y_data[,(length(ages)-9):length(ages)]) 

## solutions

##init_p <- expo(y_data[,7],0.5*loga(y_data[,7],y_data[,12]))
##init_p <- expo(y_data[,1],0.5*loga(y_data[,1],y_data[,2]))
init_p <- k_mean(y_data)
init_v <- t(t(integer(embed)))

ans <- alg(init_p,init_v,x_data,y_data,estimator)

total_var <- k_mean_loss_sum(k_mean(y_data),y_data)
unexp_var <- loss_sum(ans[[1]],ans[[2]],x_data,y_data,'l2')
r_sq <- 1-unexp_var/total_var

r_sq

ans[[1]]
t(ans[[2]])
sum(ans[[1]]*Conj(ans[[2]]))
norm(ans[[1]])
sum(ans[[1]])
sum(ans[[2]])
ans[[3]]
ans[[4]]
ans[[5]]


## permutations

permuted_var <- vector(length=M)
perm_r_sqds <- vector(length=M)

for (k in 1:M) {
  set.seed(20000+k)
  permuted_x <- sample(x_data,length(x_data),replace=F)
  permuted_ans <- alg(init_p,init_v,permuted_x,y_data,estimator)
  permuted_var[k] <- loss_sum(permuted_ans[[1]],permuted_ans[[2]],permuted_x,y_data,'l2')
  perm_r_sqds[k] <- 1-permuted_var[k]/total_var
  if (k%%10 == 0) {
    print(k)
    print(perm_r_sqds[(k-9):k])
  }
}

sum(r_sq < perm_r_sqds)/M















## data

set.seed(1000)

NCF_x_data <- readMat('../downloads/ADNI_RMRSS/data/NCinfoF.mat')$NCinfoF
NCM_x_data <- readMat('../downloads/ADNI_RMRSS/data/NCinfoM.mat')$NCinfoM
ADF_x_data <- readMat('../downloads/ADNI_RMRSS/data/ADinfoF.mat')$ADinfoF
ADM_x_data <- readMat('../downloads/ADNI_RMRSS/data/ADinfoM.mat')$ADinfoM

NCF_y_data <- readMat('../downloads/ADNI_RMRSS/data/NCLdataF.mat')$NCLdataF
NCM_y_data <- readMat('../downloads/ADNI_RMRSS/data/NCLdataM.mat')$NCLdataM
ADF_y_data <- readMat('../downloads/ADNI_RMRSS/data/ADLdataF.mat')$ADLdataF
ADM_y_data <- readMat('../downloads/ADNI_RMRSS/data/ADLdataM.mat')$ADLdataM

NCF_sample <- sample(dim(NCF_x_data)[1],n[1])
NCM_sample <- sample(dim(NCM_x_data)[1],n[2])
ADF_sample <- sample(dim(ADF_x_data)[1],n[3])
ADM_sample <- sample(dim(ADM_x_data)[1],n[4])

ages <- c(NCF_x_data[NCF_sample,9],NCM_x_data[NCM_sample,9],ADF_x_data[ADF_sample,9],ADM_x_data[ADM_sample,9])
diagnoses <- c()
diagnoses[1:(n[1]+n[2])] <- 0
diagnoses[(n[1]+n[2]+1):(sum(n))] <- 1
genders <- c()
genders[1:n[1]] <- 0
genders[(n[1]+1):(n[1]+n[2])] <- 1
genders[(n[1]+n[2]+1):(n[1]+n[2]+n[3])] <- 0
genders[(n[1]+n[2]+n[3]+1):(sum(n))] <- 1

x_data <- matrix(,nrow=length(ages),ncol=l)
x_data[,1] <- ages
x_data[,2] <- diagnoses
x_data[,3] <- genders
#x_data[,4] <- ages*diagnoses

x_data <- rbind(x_data,matrix(c(80,1,1),nrow=1))
for (i in 1:l) {
  x_data[,i] <- x_data[,i]-mean(x_data[,i]) ## centering
}

y_data <- abind(abind(abind(NCF_y_data[,,NCF_sample],NCM_y_data[,,NCM_sample]),ADF_y_data[,,ADF_sample]),ADM_y_data[,,ADM_sample])
y_data <- aperm(y_data, c(2,1,3))

for (i in 1:length(ages)) { ## remove translation
  for (j in 1:2) {
    y_data[j,,i] <- y_data[j,,i]-mean(y_data[j,,i])
  }
}

#y_data <- y_data[,1:embed,] ## remove last point, since it is determined by the first 49 points

for (i in 1:length(ages)) { ## remove scaling
  y_data[,,i] <- y_data[,,i]/((sum(y_data[,,i]*y_data[,,i]))^0.5)
}

#y_data[2,,(length(ages)-9):length(ages)] <- -y_data[2,,(length(ages)-9):length(ages)] ### fake points

fake_point <- vector(length=boundary_points)
fake_point[1] <- exp((pi/boundary_points)*((-1+0i)^0.5))
for (i in 2:boundary_points) {
  fake_point[i] <- (fake_point[1])^i
}
fake_point <- ((1/boundary_points)^0.5)*fake_point
fake_point <- rbind(Re(fake_point),Im(fake_point))
y_data <- abind(y_data,fake_point)

count <- 0
old_target <- -y_data[,,1] ## remove rotation, general procrustes analysis
current_target <- y_data[,,1]
while ((sum((current_target-old_target)*(current_target-old_target))^0.5)>0.00000001) {
  for (i in 1:length(ages)) {
    decomp <- svd(current_target%*%t(y_data[,,i]))
    R <- (decomp$u)%*%t(decomp$v)
    y_data[,,i] <- R%*%y_data[,,i]
  }
  old_target <- current_target
  current_target <- rowSums(y_data,dims=2)
  current_target <- current_target/((sum(current_target*current_target))^0.5)
  count <- count+1
}

y_data <- y_data[1,,]+y_data[2,,]*(0+1i)

## y_data <- rbind(y_data[1,,],y_data[2,,])

## solutions

init_p <- k_mean(y_data)
init_v <- matrix(0L,nrow=embed,ncol=l)
##for (h in 1:length(x_data[1,])) {
##  max_p <- y_data[,which.max(x_data[,h])]
##  init_v[,h] <- loga(init_p,max_p)/max(x_data[,h])
##}

ans <- alg(init_p,init_v,x_data,y_data,estimator)

total_var <- k_mean_loss_sum(k_mean(y_data),y_data)
unexp_var <- loss_sum(ans[[1]],ans[[2]],x_data,y_data,'l2')
r_sq <- 1-unexp_var/total_var

r_sq

sum(ans[[1]]*Conj(ans[[2]]))
norm(ans[[1]])
ans[[3]]
ans[[4]]
ans[[5]]

## permutations

permuted_var <- c()
perm_r_sqds <- c()

for (k in 1:M) {
  set.seed(20000+k)
  permuted_x <- matrix(0L,nrow=length(x_data[,1]),ncol=l)
  for (h in 1:length(x_data[1,])) {
    permuted_x[,h] <- sample(x_data[,h],length(x_data[,h]),replace=F)
  }
  permuted_ans <- alg(init_p,init_v,permuted_x,y_data,estimator)
  permuted_var[k] <- loss_sum(permuted_ans[[1]],permuted_ans[[2]],permuted_x,y_data,'l2')
  perm_r_sqds[k] <- 1-permuted_var[k]/total_var
  if (k%%10 == 0) {
    print(k)
    print(perm_r_sqds[(k-9):k])
  }
}

sum(r_sq < perm_r_sqds)/k

r_sq

```
